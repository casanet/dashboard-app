/* eslint-disable no-useless-escape */
/* eslint-disable no-multi-str */
/* eslint-disable import/no-extraneous-dependencies */
import nodeFetch from 'node-fetch';
import fs from 'fs';
import path from 'path';
import jszip from 'jszip';

// #region Commons
// Build API based on develop branch, unless it's build for main branch, then use main branch API.
const ENV_BRANCH = process.env.BRANCH !== 'main' ? 'development' : 'master';
const SELF_NAME = 'generate-api.js';
const NODE_BUFFER = 'nodebuffer';

console.log(`[generate-api] Generating API for branch "${process.env.BRANCH}" from server "${ENV_BRANCH}" branch...`);

const SWAGGER_GEN_REQUEST_BODY = {
	lang: 'typescript-fetch',
	specURL: `https://raw.githubusercontent.com/casanet/casanet-server/${ENV_BRANCH}/backend/src/swagger.json`,
	type: 'CLIENT',
	codegenVersion: 'V3',
	options: {
		supportsES6: true,
	},
};
// #endregion Commons

// #region Swagger File Names
const CUSTOM_D_TS = 'custom.d.ts';
const CONFIGURATION_TS = 'configuration.ts';
const API_TS = 'api.ts';
const INDEX_TS = 'index.ts';
// #endregion Swagger File Names

// #region Output Paths
const OUTPUT_BASE_PATH = 'src/infrastructure/generated';
const SWAGGER_API_OUTPUT_PATH = `${OUTPUT_BASE_PATH}/api`;
const CHANNEL_SPEC_PATH = `${SWAGGER_API_OUTPUT_PATH}/channel-spec.ts`;
const SHARED_MODELS_PATH = `${SWAGGER_API_OUTPUT_PATH}/sharedInterfaces.ts`;
const PROXY_EMISSION_OUTPUT_DIR = `${OUTPUT_BASE_PATH}/proxies`;
const PROXY_EMISSION_OUTPUT_FILE = `${PROXY_EMISSION_OUTPUT_DIR}/api-proxies.ts`;
// #endregion Output Paths

// #region Re-writes
const PORTABLE_PORTABLE_FETCH_REGEX = /import.+portable\-fetch\.*?\"\.*?\;/;
const PORTABLE_ISOMORPHIC_FETCH_REGEX = /import.+isomorphic\-fetch\.*?\"\.*?\;/;
const PORTABLE_FETCH_REWRITE_CONTENT = 'const portableFetch = fetch;';
const PORTABLE_FETCH_ISOMORPHIC_REWRITE_CONTENT = 'const isomorphicFetch = fetch;';

const BASE_PATH_REGEX = /const\s+BASE_PATH\s+=\s+.+?\;/;
const BASE_PATH_REWRITE_CONTENT = `// Auto-generated by '${SELF_NAME}'\n\
import { envFacade } from '../../env-facade';`;

const BASE_PATH_ENV_VAR = 'BASE_PATH';
const BASE_PATH_REPLACEMENT = 'envFacade.apiUrl';

const CLASS_DEFS_REGEX = /export[\t ]+class\s+(?<className>[\w\d]+)\s+extends\s+BaseAPI/g;

const INJECT_PARAMS_FIND_REGEX = /delete.+?localVarUrlObj\.search\s*?;.*?\n/g;
const INJECT_PARAMS_FIND_CONTENT = "\
						delete localVarUrlObj.search;\n\
						localVarRequestOptions.credentials = 'include';\n\
";

const URL_PARSE_ISSUES_RETURNED = 'url.parse(localVarPath, true);';
const URL_PARSE_FIXED_CONTENT = 'url.parse(localVarPath, true) as any;';

const SWITCH_NAME_GEN_ISSUES = '_switch?: ModelSwitch;';
const SWITCH_NAME_GEN_CONTENT = 'switch?: ModelSwitch;';


// #endregion Re-writes

// #region Proxies File

const AUTO_GEN_COMMENT = `\n// This file was AutoGenerated at ${new Date()} by '${SELF_NAME}'\n\n`;

const PROXY_CORE_IMPORT_STATEMENT = "import { createApiProxy } from '../../api-proxy-core';\n";

const CRED_MGR_IMPORT_STATEMENT = "import { sessionManager } from '../../session-manager';\n";

const FACADE_CLASS_START_STATEMENT = '\n\nexport class ApiFacade {\n';
const FACADE_CLASS_END_STATEMENT = '}\n';

const PROXY_GETTER_STATEMENT_FORMAT = '\
	public static get {0}(): {0} {\n\
		return createApiProxy(new {0}({ apiKey: sessionManager.getToken() }));\n\
	}\n\n';

// #endregion Proxies File

/**
 * Recursively ensures the given directory path exists, creating it as necessary
 *
 * @param {string} dirPath The path to ensure
 * @return {void}
 */
function mkdirRecursive(dirPath) {
	if (fs.existsSync(dirPath)) {
		return;
	}
	const dirname = path.dirname(dirPath);
	mkdirRecursive(dirname);
	fs.mkdirSync(dirPath);
}

/**
 * Gets a file from the given `jsZip` archive and writes it to the `SWAGGER_API_OUTPUT_PATH`
 *
 * @param {JSZip} jsZip The archive containing the file
 * @param {string} fileName The file's name
 */
async function depositFile(jsZip, fileName) {
	const fileBuffer = await jsZip.file(fileName).async(NODE_BUFFER);
	fs.writeFileSync(path.join(SWAGGER_API_OUTPUT_PATH, fileName), fileBuffer);
}

/**
 * Creates an import statement for including the given 'importNames' from the generated api.ts file
 *
 * @param {string[]} importNames An array of entities to import  from 'api.ts'
 * @return {string[]}
 */
function createImportStatement(importNames) {
	return `import { ${importNames.join(', ')} } from '../api/api'`;
}

/**
 * Creates the `api.ts` file
 * @description This method reads the `api.ts` from the Swagger generated archive,
 * amends it to fit our codebase and deposits it into `SWAGGER_API_OUTPUT_PATH`
 *
 * @param {JSZip} jsZip The Swagger generated archive containing the `api.ts` file
 * @return {string[]} An array of the API class names defined in `api.ts`
 */
async function createApiTs(jsZip) {
	// Read the file from the archive
	let fileContents = (await jsZip.file(API_TS).async(NODE_BUFFER)).toString();

	// Replace 'portableFetch' with regular 'fetch' if swagger gen this kind of fetch method
	fileContents = fileContents.replace(PORTABLE_PORTABLE_FETCH_REGEX, PORTABLE_FETCH_REWRITE_CONTENT);

	// Replace 'isomorphicFetch' with regular 'fetch' if swagger gen this kind of fetch method
	fileContents = fileContents.replace(PORTABLE_ISOMORPHIC_FETCH_REGEX, PORTABLE_FETCH_ISOMORPHIC_REWRITE_CONTENT);

	// Replace the BASE_PATH variable with a reference to envFacade.apiPath
	fileContents = fileContents.replace(BASE_PATH_REGEX, BASE_PATH_REWRITE_CONTENT);

	// Add the "credentials: 'include'" option to all APIs
	fileContents = fileContents.replace(INJECT_PARAMS_FIND_REGEX, INJECT_PARAMS_FIND_CONTENT);

	// In order to allow delete optional search param, set 'url.parse' return as any.
	fileContents = fileContents.split(URL_PARSE_ISSUES_RETURNED).join(URL_PARSE_FIXED_CONTENT);

	// Replace all BASE_PATH with the 'envFacade.apiUrl' to allow change the api url on demand
	fileContents = fileContents.split(BASE_PATH_ENV_VAR).join(BASE_PATH_REPLACEMENT);

	// From some reason, swagger ge, creates the props'switch' with underscore prefix.
	fileContents = fileContents.replace(SWITCH_NAME_GEN_ISSUES, SWITCH_NAME_GEN_CONTENT);

	// Write the file to the output path
	fs.writeFileSync(path.join(SWAGGER_API_OUTPUT_PATH, API_TS), fileContents);

	// Find all class definitions deriving from the BaseAPI class and return their names as an array
	const apiClasses = fileContents.matchAll(CLASS_DEFS_REGEX);
	const proxiesToEmit = Array.from(apiClasses).map((match) => match.groups.className);
	return proxiesToEmit;
}

/**
 * Emits a class containing, for each class name in `proxiesToEmit` a static getter returning a dynamic proxy of the API object
 * @description **Note:** This method requires that the output directory already exists. The output file may or may not exist
 *
 * The same could be done by adjusting swagger's typescript-fetch template but that is a bit overkill
 *
 * @param {string[]} proxiesToEmit An array of class names to generate getters for
 */
function emitProxiesFile(proxiesToEmit) {
	// Delete the generated file, if it already exists
	if (fs.existsSync(PROXY_EMISSION_OUTPUT_FILE)) {
		fs.unlinkSync(PROXY_EMISSION_OUTPUT_FILE);
	}

	// Ensure the output directory exists
	mkdirRecursive(PROXY_EMISSION_OUTPUT_DIR);

	// Emit static imports
	fs.appendFileSync(PROXY_EMISSION_OUTPUT_FILE, AUTO_GEN_COMMENT);
	fs.appendFileSync(PROXY_EMISSION_OUTPUT_FILE, PROXY_CORE_IMPORT_STATEMENT);
	fs.appendFileSync(PROXY_EMISSION_OUTPUT_FILE, CRED_MGR_IMPORT_STATEMENT);

	// Emit dynamic imports (all classes from the Swagger generated code)
	const importStatement = createImportStatement(proxiesToEmit);
	fs.appendFileSync(PROXY_EMISSION_OUTPUT_FILE, importStatement);

	// Emit the Facade class's beginning
	fs.appendFileSync(PROXY_EMISSION_OUTPUT_FILE, FACADE_CLASS_START_STATEMENT);

	// Emit a getter for each proxy
	for (const proxyToEmit of proxiesToEmit) {
		fs.appendFileSync(PROXY_EMISSION_OUTPUT_FILE, PROXY_GETTER_STATEMENT_FORMAT.replace(/\{0\}/g, proxyToEmit));
	}

	// Emit the facade class's end
	fs.appendFileSync(PROXY_EMISSION_OUTPUT_FILE, FACADE_CLASS_END_STATEMENT);
}

/**
 * Download a source (text) file in order to use (for example a TS declaration file etc)
 * @param {*} filePath The file URI
 * @param {*} sourceDestination The path/name where to place the fetched file
 */
async function downloadSourceFile(filePath, sourceDestination) {
	const sharedModelsResponse = await nodeFetch(filePath);
	const sharedModelsResponseBuffer = await sharedModelsResponse.buffer();
	fs.writeFileSync(path.join(sourceDestination), AUTO_GEN_COMMENT);
	fs.appendFileSync(path.join(sourceDestination), sharedModelsResponseBuffer);
}

(async () => {
	// Send a Swagger Generation request
	const generateClient = {
		method: 'POST',
		body: JSON.stringify(SWAGGER_GEN_REQUEST_BODY),
		headers: { 'Content-Type': 'application/json', Accept: 'application/octet-stream' },
	};

	const genResponse = await nodeFetch('https://generator3.swagger.io/api/generate', generateClient);
	const buffer = await genResponse.buffer();

	// 2: Extract generated API
	const generatedZip = await jszip.loadAsync(buffer);

	// Make sure the output directory exists
	mkdirRecursive(SWAGGER_API_OUTPUT_PATH);

	// Drop some of the Swagger generated files as-is
	await depositFile(generatedZip, CONFIGURATION_TS);
	await depositFile(generatedZip, CUSTOM_D_TS);
	await depositFile(generatedZip, INDEX_TS);

	// Modify and drop the api.ts file
	const apiClassNames = await createApiTs(generatedZip);

	// Emit a Facade class with a getter for every API class in the api.ts file.
	emitProxiesFile(apiClassNames);

	// Download the latest channel TS spec API
	await downloadSourceFile(`https://raw.githubusercontent.com/casanet/casanet-server/${ENV_BRANCH}/backend/src/models/remote2localProtocol.ts`, CHANNEL_SPEC_PATH);
	await downloadSourceFile(`https://raw.githubusercontent.com/casanet/casanet-server/${ENV_BRANCH}/backend/src/models/sharedInterfaces.d.ts`, SHARED_MODELS_PATH);
})();
